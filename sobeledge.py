# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jk7ltP8FYhP59-q2ljFPwCthKrsVYwBI
"""

!pip install -U scikit-image
!pip install -U -q PyDrive
from skimage.exposure import rescale_intensity
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials
#dependencies, note we will not be using all these dependencies but i love having them up there just in case.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize']= [16,10]
import seaborn as sns
from sklearn.model_selection import train_test_split
import xgboost as xgb
import cv2
import matplotlib.image as mpimg
import argparse

# %matplotlib inline
plt.rcParams['axes.unicode_minus']= False


#authenticate
auth.authenticate_user()
gauth= GoogleAuth()
gauth.credentials= GoogleCredentials.get_application_default()
drive= GoogleDrive(gauth)

image = drive.CreateFile({'id':'1JWRQPIDrvpdSRJNX25lW53Cl9sQbII31'})
image.GetContentFile('mri2.jpg')

img= mpimg.imread('mri2.jpg')
plt.imshow(img)
gray_I = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
plt.imshow(gray_I, cmap='gray')

#The code below is going to create a 5 by 5 custom kernel for edge dectection
# The first pair of kernels will be a 3 by 3 sobel operator, The sobel operator is good
# at finding patterns in intensity in an image
# To create the sobel operator we are going to use the numpy library specifically the np.array operator

# I like to kep my arrays looking neat its almost a neurotic impulse you dont have to structure it like this
sobel3_y = np.array([[ -1, -2, -1], 
                     [  0,  0,  0], 
                     [  1,  2,  1]])


sobel3_x = np.array([[-1, 0 , 1 ],
                     [-2,  0,  2 ],
                     [-1,  0,  1 ] ])
# now we are going to apply this kernel to the converted grayscale image and we'll get some cool edge detection action
                     
filtered_image = cv2.filter2D(gray_I, -1, sobel2_X)
plt.imshow(filtered_image, cmap='gray')
                     
# Now i will create a 5 by 5 sobel kernel for edge detection
                     


sobel2_Y = np.array([[2, 2, 4, 2, 2 ],
                     [1, 1, 2, 1, 1 ],
                     [0, 0, 0 ,0, 0 ],
                     [-1,-1,-2,-1,-1],
                     [-2,-2,-4,-2,-2] ])


# 5 by 5 kernel sobel with decimal weight values
sobel2_X = np.array([[2.3, 1.5, 0,-1.5,-2.3 ],
                     [2.3, 1.5, 0,-1.5, -2.3 ],
                     [4.2, 2.3, 0,-2.3, -4.2 ],
                     [2.3, 1.5, 0,-1.5,-2.3],
                     [2.3, 1.5, 0,-1.5,-2.3] ])

